#I use this to calculate the 21-cm signal for the box. I take only Palpha as input which is outputted from RASCAS #output. Everything else (number densities or temperatures) are taken from RAMSES output.

import yt
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy.io import FortranFile as ff
import scipy.misc as scmi
import scipy.special as scsp
import scipy.integrate as scint
import scipy.fft as scft
from colossus.cosmology import cosmology
from colossus.lss import peaks

outnum = 15	#RAMSES Snapshot number
simid1='hydro-cool3/output_000'+str(outnum)+'/'	
simid ='10cMpc_256/'

#-----------------------------------------------------------------------------------------------
#Fundamental constants in SI units
cE = 2.99792458e8
kB = 1.38e-23
hP = 6.634e-34
G = 6.67e-11
mH = 1.67e-27
lam_alpha = 121.567e-9
A_alpha = 6.25e8
hP_by_e = (2.417e14)**-1
kmbyMpc=1/(3.086e19)

#-----------------------------------------------------------------------------------------------
# reading palpha data generated by RASCAS.
ras = '/mnt/exports/data/mittal/outras/'+simid+'pa'+'.dat'
print('\nReading RASCAS data from',ras,' ...')
f = ff(ras)
[lev] = f.read_ints()
raw = f.read_reals('d')
np.nan_to_num(raw,copy=False)	

palpha = np.reshape(raw,[2**lev,2**lev,2**lev],order='F')
#The "order='F'" signifies the FORTRAN style of saving arrays.
print('Done.\n')

palpha_mean=np.mean(palpha)
print('min non-zero P_alpha = ',np.min(palpha[palpha>0]))
print('max P_alpha = ',np.max(palpha),'\n')
#print('<P_alpha>=',palpha_mean,'sec^-1\n')
#---------------------------------------------------------------------------------------------

#Reading RAMSES data, such as temperature density, number density, etc.

ram = '/mnt/exports/data/mittal/outram/'+simid1
print('Reading RAMSES data from',ram,' ...')
ds = yt.load(ram)
cr_rdshft = ds.current_redshift

cg = ds.covering_grid(level=0, left_edge=[0.0, 0.0, 0.0], dims=[2**lev, 2**lev, 2**lev])
cg.set_field_parameter("omega_baryon", 0.049)

Tk=cg['gas','temperature'].d
nHI=(cg['gas','HI_number_density'].to('m**-3')).d
npr=cg['gas','HII_number_density'].to('m**-3').d
bod=cg['gas','baryon_overdensity'].d
ne=cg['gas','Electron_number_density'].to('m**-3').d
print('Done.')

Tk_mean=np.mean(Tk)
npr_mean=np.mean(npr)
nHI_mean=np.mean(nHI)
ne_mean=np.mean(ne)
bod_mean=np.mean(bod)

print('\nz = ',"%.3f" % cr_rdshft)
print('<Tk> = ',"%.3f" % Tk_mean,'K')
print('max(Tk) =',np.max(Tk))
print('min(Tk) =',np.min(Tk))
print('<nHI> = ',"%.3f" % nHI_mean,'m^-3')
print('<nHII> = ',"%.3f" % npr_mean,'m^-3')
print('<ne> = ',"%.3f" % ne_mean,'m^-3')
print('<1+delta> = ',"%.3f" % bod_mean)


#---------------------------------------------------------------------------------------
Tstar = 0.068
A_10 = 2.85e-15
lam21=0.211
Tcmb0=2.725
Om_L = ds.omega_lambda
Om_m = ds.omega_matter
Om_b = 0.049
h_Hubble = ds.hubble_constant
Ho = 100*h_Hubble
Yp = 0.24

Tcmb=Tcmb0*(1+cr_rdshft)
print('T_cmb = ',"%.3f" % Tcmb,'K\n')

rho_b=3*Ho**2*kmbyMpc**2/(8*np.pi*G)*Om_b	#in kg.m^-3

L_cMpc_by_h = ds.length_unit.in_units('Mpccm').d*h_Hubble	#Box length in units of cMpc/h
Del_r_cMpc = ds.length_unit.in_units('Mpccm').d/2**lev		#Cell length in cMpc
L_m_co = ds.length_unit.in_units('mcm').d			#Box length in units of metre (comoving)
Del_r_code_units = 1/2**lev  					#Cell length in code units

my_cosmo = {'flat': True, 'H0': Ho, 'Om0': Om_m, 'Ob0': Om_b, 'sigma8': 0.811, 'ns': 0.965,'relspecies': False,'Tcmb0': Tcmb0}
cosmo = cosmology.setCosmology('my_cosmo', my_cosmo)

#-------------------------------------------------------------------------------------------

def H(zed):	#in sec^-1
	Z=1+zed
	return kmbyMpc*Ho*(Om_m*Z**3+Om_L)**0.5

def xalpha(palpha):	#p_alpha comes from RASCAS simulation.
	return (Tstar/Tcmb)*4*palpha/(27*A_10)


def ks(Tk):	#in m^-3.s^-1
	kHH = 3.1*10**(-17)*Tk**0.357*np.exp(-32/Tk)
	lnT=np.log(Tk)
	kpH = (4.28+0.1023*lnT-0.2586*lnT**2+0.04321*lnT**3)*1e-16
	if np.size(Tk)!=1:
		Tk[Tk<1]=1
	else:
		if Tk<1:
			Tk=1
	keH = 10**(-15.609+0.5*np.log10(Tk)*np.exp(-(np.log10(Tk))**4.5/1800))
	return kHH, keH, kpH

def xk(Tk,nHI,ne,npr):
	kHH, keH, kpH=ks(Tk)
	return Tstar*(nHI*kHH + ne*keH + npr*kpH)/(A_10*Tcmb)

def xcmb_Ts(zed,Tk,xk1,xalpha1,nHI):
	xcmb=np.ones((np.shape(Tk)))
	for i in range(3):
		Ts = ( xcmb + xk1 + Tk*xalpha1/(Tk+0.4) )/((xcmb/Tcmb) + xk1/Tk + xalpha1/(Tk+0.4) )
		tau21 = 3*lam21**3*A_10*Tstar*nHI/(32*np.pi*H(zed)*Ts)
		xcmb = (1-np.exp(-tau21))/tau21
	return xcmb,Ts

def sig21cm(zed,Tk,nHI,ne,npr,palpha):
	xa=xalpha(palpha)
	x_coll=xk(Tk,nHI,ne,npr)
	print('np.mean(x_coll)=',np.mean(x_coll))
	xcmb,Ts=xcmb_Ts(zed,Tk,x_coll,xa,nHI)
	return 1000*3*lam21**3*A_10*Tstar/(32*np.pi*H(zed)*(1+zed))*nHI*(1-Tcmb/Ts)	#in mK
#--------------------------------------------------------------------------------------------

#============================================================================================

fn = ram[:-13]+'info_'+ram[-6:-1]+'/info_' + ram[-6:-1] +'.0.h5'
print('\nReading halo data from',fn,' ...\n')
dsh = yt.load(fn)
adh = dsh.all_data()             
M_haloes = adh['halos','particle_mass']
n_haloes = np.size(M_haloes)
Xgas = cg['gas','x'].in_units('code_length').d-0.5
Ygas = cg['gas','y'].in_units('code_length').d-0.5
Zgas = cg['gas','z'].in_units('code_length').d-0.5

Del_rc = L_m_co/2**lev	#Cell length in comoving metre

#For a given comoving distance rc (m) return the upper z for a given lower z
def zprime(zed,rc):
	return (1+zed)*(1-0.5*Ho*kmbyMpc*rc/cE*np.sqrt(Om_m*(1+zed)))**(-2)-1

#Returns the SED in number of photons per unit Hz per baryon.
def phi(zed,zedp):
	zp_by_z=(1+zedp)/(1+zed)
	loc = np.where(zp_by_z>=32/27)
	to_return = hP_by_e*2902.91*(0.75*(1+zedp)/(1+zed))**-0.86
	to_return[loc]=0
	return to_return

f_star=0.1
def SFRD(zed):	#in kg.m^-3.sec^-1
	def f_coll(zed):
	    return scsp.erfc(peaks.peakHeight((Om_m)**(-0.5)*3.91E8*(1+zed)**-1.5,zed)/np.sqrt(2))

	dFbydz=scmi.derivative(f_coll,zed,1e-4)
	return -f_star*rho_b*H(zed)*(1+zed)*dFbydz

#Computes the specific intensity Ja (m^-2.s^-1.Hz^-1.sr^-1) at the requested position r and redshift z
def J_alpha(zed):
	sfr_per_halo_by_Vcell = 8**lev*SFRD(zed)/n_haloes

	#Getting a 3D box of SFRD:-
	rho_star_dot = np.zeros((2**lev,2**lev,2**lev))
	for i in range(n_haloes):
		ith_halo = dsh.halo("halos",i) #loading the ith halo
		ith_halo_pos = ith_halo.position.in_units("code_length").d #ith halo position in code units
		ix,jy,kz = np.int_(ith_halo_pos/Del_r_code_units)
		rho_star_dot[ix,jy,kz] = rho_star_dot[ix,jy,kz] + sfr_per_halo_by_Vcell
	#Done. That's 1st function prepared for convolution.
	
	radii_prime = np.sqrt(Xgas**2 + Ygas**2 + Zgas**2) * L_m_co
	zp = zprime(zed,radii_prime)
	func2 = phi(zed,zp)/radii_prime**2	#That's 2nd function prepared for convolution.
	prefactor = (1+zed)**2/(4*np.pi*1.22*mH*4*np.pi)
	return prefactor*np.abs((scft.fftshift(scft.ifftn(scft.fftn(rho_star_dot)*scft.fftn(func2)))))*Del_rc**3

def xalpha_old(zed,nHI,Tk):
	Jo=5.54e-8*(1+zed)		#(m^-2.s^-1.Hz^-1.sr^-1)
	a=4.71e-4*np.sqrt(Tk*1e-4)	#Natural to Dopplar width
	tau=3/(8*np.pi)*A_alpha/H(zed)*nHI*lam_alpha**3	#Lya optical depth (Gunn & Peterson 1965)
	eta=0.02535/np.sqrt(Tk)		#Recoil parameter
	xi=4/3*np.sqrt(a*tau*eta**3/np.pi)
	S=np.exp(-1.69*xi**(2/3))	#Using the approx. from Chuzhoy & Shapiro (2007)
	if np.size(nHI)==1:
		return S*np.mean(J_alpha(zed))/Jo
	else:
		return S*J_alpha(zed)/Jo

def sig21cm_old(zed,Tk,nHI,ne,npr):
	xa = xalpha_old(zed,nHI,Tk)
	x_coll = xk(Tk,nHI,ne,npr)
	xcmb,Ts = xcmb_Ts(zed,Tk,x_coll,xa,nHI)
	return 1000*3*lam21**3*A_10*Tstar/(32*np.pi*H(zed)*(1+zed))*nHI*(1-Tcmb/Ts)	#in mK

#==============================================================================================


#----------------------------------------------------------------------------------------------

print('=============================================================')
print('Now doing all the 21-cm related calculations...\n')

print('With multiple scattering:')

xa_new = xalpha(palpha)
print('min(xa_new),max(xa_new) = ',np.min(xa_new[xa_new>0]),np.max(xa_new))

'''
xa_new_mean = np.mean(xa_new)
xk_mean = xk(Tk_mean,nHI_mean,ne_mean,npr_mean)
xcmb_mean,Ts_mean = xcmb_Ts(cr_rdshft,Tk_mean,xk_mean,xa_new_mean,nHI_mean)

print('xcmb = ',"%.3f" % xcmb_mean)
print('xa = ', xa_new_mean)
print('xk = ', xk_mean)
print('Ts = ',"%.3f" % Ts_mean)
'''

T21_new = sig21cm(cr_rdshft,Tk,nHI,ne,npr,palpha)
print('\nThe box average = ',"%.3f" % np.mean(T21_new),'mK')
print('Min and max 21-cm signal =',np.min(T21_new), np.max(T21_new),'mK')

#==============================================================================================
print('-------------------------------------------------------------')

#print('\nWithout multiple scattering:')

xa_old = xalpha_old(cr_rdshft,nHI,Tk)
print('min(xa_old),max(xa_old) = ',np.min(xa_old),np.max(xa_old))
'''
xa_old_mean=xalpha_old(cr_rdshft,nHI_mean,Tk_mean)
xcmb_mean,Ts_mean = xcmb_Ts(cr_rdshft,Tk_mean,xk_mean,xa_old_mean,nHI_mean)

print('xcmb = ',"%.3f" % xcmb_mean)
print('xa = ',"%.3f" % xa_old_mean)
print('xk = ', xk_mean)
print('Ts = ',"%.3f" % Ts_mean)
'''

T21_old = sig21cm_old(cr_rdshft,Tk,nHI,ne,npr)
print('\nThe box average = ',"%.3f" % np.mean(T21_old),'mK')
print('Min and max 21-cm signal =',np.min(T21_old), np.max(T21_old),'mK')
print('=============================================================')


#==============================================================================================
#----------------------------------------------------------------------------------------------

output_dir = '/mnt/exports/data/mittal/outras/'
#np.save(output_dir+simid+'T21',T21_new)
#np.save(output_dir+simid+'xa',xa_new)
#np.save(output_dir+simid+'T21_old',T21_old)
#np.save(output_dir+simid+'xa_old',xa_old)
